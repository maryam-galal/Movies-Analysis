# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1slvk4QJOktIMQeeDMMe7dyCz_C_kB9fL

# First, we import the libraries we need
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

pd.set_option('display.max_columns', None)  #modify pandas settings to display all columns

"""# Read the data into a dataframe"""

movie_details = pd.read_csv("/content/tmdb_movie_details.csv")

"""# Diving into the data"""

# look at the first 5 rows
movie_details.head(20)

movie_details.info()

movie_details.shape

movie_details.describe()   #generating decriptive statistics of the dataset

"""# Dropping columns we won't need in our analysis"""

movie_details.columns

#we don't need column backdrop_path, homepage, overview posterpath or tagline in our analysis
#as they're not quantitave or qualitative data

columns = ['backdrop_path', 'homepage', 'overview', 'poster_path', 'tagline']

movie_details.drop(columns, axis = 1, inplace = True)  #we used inplace=True to modify the original Dataframe

movie_details['video']

print(movie_details['video'].value_counts())
print(movie_details['adult'].value_counts())

#dropping column video and adult as they are all False
columns = ['video' , 'adult']
movie_details.drop(columns, axis = 1, inplace = True)

#found title and original_title, do we need them both?

movie_details['original_title'].head(10)

movie_details['title'].head(10)

movie_details['title'].nunique()

movie_details[movie_details['title'].duplicated(keep = False)].sort_values(by = 'title')

# we will drop original_title since some characters aren't correct and it has the same value as title, but
# column title doesn't have any bad characters
movie_details.drop(columns="original_title", inplace=True)

# since we removed the original title we need to rename the title column to english title to know that this
# isn't the original title, but a translated one
movie_details.rename(columns={"title": "english_title"} , inplace=True)

#found id and imdb_id, do we need them both?

movie_details['id'].isnull().sum()

movie_details['imdb_id'].isnull().sum()

#drop the imdb_id column because we already have the clean id column
movie_details.drop(columns="imdb_id",inplace=True)

"""# Change data types"""

movie_details.info()

movie_details['release_date'] = pd.to_datetime(movie_details['release_date'], errors='coerce')

movie_details.info()

movie_details['status'].value_counts()

"""# Dealing with Duplicates"""

movie_details[movie_details.duplicated(keep=False)].sort_values(by='id')

movie_details.duplicated().sum()

#dropping movie_details duplicates
movie_details.drop_duplicates(inplace=True)

"""# Dealing with inconsistency"""

movie_details['status'].unique()

current_day = pd.Timestamp(year=2025, month=1, day=28)
condition = (movie_details['release_date'] > current_day) & (movie_details['status'] == "Released")
movie_details[condition][['release_date', 'status']].sort_values(by='release_date')

current_day = pd.Timestamp(year=2025, month=1, day=28)
condition = (movie_details['release_date'] > current_day) & (movie_details['status'] == "Released")
movie_details.loc[condition, 'status'] = 'Post Production'

current_day = pd.Timestamp(year=2025, month=1, day=28)
condition = (movie_details['release_date'] > current_day) & (movie_details['status'] == "Released")
movie_details[condition][['release_date', 'status']].sort_values(by='release_date')

condition = (movie_details['vote_count'] == 0) & (movie_details['vote_average'] != 0)
movie_details.loc[condition]

condition = (movie_details['vote_count'] == 0) & (movie_details['status'] =="Released") & (movie_details['revenue'] == 0) & (movie_details['budget'] == 0) & \
 (movie_details['genres'] == '[]')


movie_details[condition].sort_values(by='popularity', ascending = False)

condition = (movie_details['vote_count'] == 0) & (movie_details['status'] =="Released") & (movie_details['revenue'] == 0) & (movie_details['budget'] == 0) & \
 (movie_details['genres'] == '[]')
movie_details.drop(index=movie_details[condition].index, axis=0, inplace=True)

condition = (movie_details['vote_count'] == 0) & (movie_details['status'] =="Released") & (movie_details['revenue'] == 0) & (movie_details['budget'] == 0) & \
 (movie_details['genres'] == '[]')


movie_details[condition].sort_values(by='popularity', ascending = False)

condition = (movie_details['runtime'] == 0) & (movie_details['status'] == 'Released')  & (movie_details['revenue'] == 0) & (movie_details['budget'] == 0)
print(movie_details[condition]['vote_count'].sum())
print(movie_details['vote_count'].sum())

movie_details[condition].sort_values(by='vote_count')

condition = (movie_details['runtime'] == 0) & (movie_details['status'] == 'Released')  & (movie_details['revenue'] == 0) & (movie_details['budget'] == 0)

movie_details.drop(index=movie_details[condition].index, axis=0, inplace=True)

condition = (movie_details['runtime'] == 0) & (movie_details['status'] == 'Released')  & (movie_details['revenue'] == 0) & (movie_details['budget'] == 0)
print(movie_details[condition]['vote_count'].sum())
print(movie_details['vote_count'].sum())

movie_details[condition].sort_values(by='vote_count')

condition = (movie_details['runtime'] == 0) & (movie_details['status'] == 'Released')
movie_details[condition].sort_values(by='vote_count')

condition = (movie_details['runtime'] == 0) & (movie_details['status'] == 'Released')
print(movie_details[movie_details['status'] == 'Released']['runtime'].median())

movie_details.loc[condition, 'runtime'] = movie_details[movie_details['status'] == 'Released']['runtime'].median()

condition = (movie_details['runtime'] == 0) & (movie_details['status'] == 'Released')
movie_details[condition].sort_values(by='vote_count')

condition = (movie_details['runtime'] != 0) & (movie_details['status'] != 'Released')
movie_details[condition].sort_values(by='vote_count')

"""#Dealing with nulls"""

movie_details.isnull().sum()

movie_details[movie_details["release_date"].isnull()]

print(movie_details[movie_details['genres'] == '[]']['genres'].count())
movie_details[(movie_details['genres'] == '[]') & (movie_details['status'] == 'Released')]

print(movie_details[movie_details['production_companies'] == '[]']['production_companies'].count())
movie_details[(movie_details['production_companies'] == '[]') & (movie_details['status'] == 'Released')]

print(movie_details[movie_details['origin_country'] == '[]']['origin_country'].count())
movie_details[(movie_details['origin_country'] == '[]') & (movie_details['status'] == 'Released')]

movie_details.drop(index=movie_details[(movie_details['origin_country'] == '[]') & (movie_details['status'] == 'Released')].index, axis=0, inplace=True)

print(movie_details[movie_details['production_countries'] == '[]']['production_countries'].count())
movie_details[(movie_details['production_countries'] == '[]') & (movie_details['status'] == 'Released')]

"""# Check for outliers

We use Box Plot to detect outliers as the visualization to it
"""

import seaborn as sns

box = sns.boxplot(y=movie_details[movie_details['budget'] != 0]['budget'])
box.set_title("Box Plot of budget")

# Calculate Q1, Q3, and IQR
Q1 = movie_details[movie_details['budget'] != 0]['budget'].quantile(0.25)
Q3 = movie_details[movie_details['budget'] != 0]['budget'].quantile(0.75)
IQR = Q3 - Q1

# Define lower and upper bounds for outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Count outliers
outlier_count = ((movie_details[movie_details['budget'] != 0]['budget'] < lower_bound) | (movie_details[movie_details['budget'] != 0]['budget'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")
movie_details[(movie_details['budget'] < lower_bound) ]

box = sns.boxplot(y=movie_details[movie_details['status'] == 'Released']['popularity'])
box.set_title("Box Plot of popularity")

Q1 = movie_details[movie_details['status'] == 'Released']['popularity'].quantile(0.25)
Q3 = movie_details[movie_details['status'] == 'Released']['popularity'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details[movie_details['status'] == 'Released']['popularity'] < lower_bound) | (movie_details[movie_details['status'] == 'Released']['popularity'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")
print(f"Number of outliers: {outlier_count}")

box = sns.boxplot(y=movie_details[movie_details['revenue'] != 0]['revenue'])
box.set_title("Box Plot of revenue")

Q1 = movie_details[movie_details['revenue'] != 0]['revenue'].quantile(0.25)
Q3 = movie_details[movie_details['revenue'] != 0]['revenue'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details[movie_details['revenue'] != 0]['revenue'] < lower_bound) | (movie_details[movie_details['revenue'] != 0]['revenue'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")

box = sns.boxplot(y=movie_details['runtime'])
box.set_title("Box Plot of runtime")

Q1 = movie_details['runtime'].quantile(0.25)
Q3 = movie_details['runtime'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details['runtime'] < lower_bound) | (movie_details['runtime'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")

movie_details[(movie_details['runtime'] > upper_bound)].sort_values(by='runtime')

movie_details.loc[562, 'runtime'] = 0
movie_details.loc[562]

box = sns.boxplot(y=movie_details['runtime'])
box.set_title("Box Plot of runtime")

Q1 = movie_details['runtime'].quantile(0.25)
Q3 = movie_details['runtime'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details['runtime'] < lower_bound) | (movie_details['runtime'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")

box = sns.boxplot(y=movie_details[movie_details['status'] == 'Released']['vote_average'])
box.set_title("Box Plot of vote_average")

Q1 = movie_details[movie_details['status'] == 'Released']['vote_average'].quantile(0.25)
Q3 = movie_details[movie_details['status'] == 'Released']['vote_average'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details[movie_details['status'] == 'Released']['vote_average'] < lower_bound) | (movie_details[movie_details['status'] == 'Released']['vote_average'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")

box = sns.boxplot(y=movie_details[movie_details['status'] == 'Released']['vote_count'])
box.set_title("Box Plot of vote_count")

Q1 = movie_details[movie_details['status'] == 'Released']['vote_count'].quantile(0.25)
Q3 = movie_details[movie_details['status'] == 'Released']['vote_count'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details[movie_details['status'] == 'Released']['vote_count'] < lower_bound) | (movie_details[movie_details['status'] == 'Released']['vote_count'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")

"""# Normalizing

Normalization is a process where we range the data into a specefic range of values
"""

movie_details['normalized_budget'] = np.log1p(movie_details['budget'])  # log normalizing

box = sns.boxplot(y=movie_details[movie_details['budget'] != 0]['normalized_budget'])
box.set_title("Box Plot of normalized_budget")

Q1 = movie_details[movie_details['budget'] != 0]['normalized_budget'].quantile(0.25)
Q3 = movie_details[movie_details['budget'] != 0]['normalized_budget'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details[movie_details['budget'] != 0]['normalized_budget'] < lower_bound) | (movie_details[movie_details['budget'] != 0]['normalized_budget'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")

movie_details[(movie_details['budget'] != 0) & (movie_details['normalized_budget'] < lower_bound)].sort_values(by='normalized_budget').head(20)

movie_details['normalized_popularity'] = np.log1p(movie_details['popularity'])  # log normalizing

box = sns.boxplot(y=movie_details['normalized_popularity'])
box.set_title("Box Plot of popularity")

movie_details['normalized_revenue'] = np.log1p(movie_details['revenue'])  # log normalizing

box = sns.boxplot(y=movie_details[movie_details['revenue'] != 0]['normalized_revenue'])
box.set_title("Box Plot of revenue")

Q1 = movie_details[movie_details['revenue'] != 0]['normalized_revenue'].quantile(0.25)
Q3 = movie_details[movie_details['revenue'] != 0]['normalized_revenue'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details[movie_details['revenue'] != 0]['normalized_revenue'] < lower_bound) | (movie_details[movie_details['revenue'] != 0]['normalized_revenue'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}"),

movie_details[(movie_details['revenue'] != 0) & (movie_details['normalized_revenue'] < lower_bound)].sort_values(by='normalized_revenue').head(20)

movie_details['normalized_runtime'] = np.log1p(movie_details['runtime'])  # log normalizing

box = sns.boxplot(y=movie_details['normalized_runtime'])
box.set_title("Box Plot of runtime")

Q1 = movie_details['normalized_runtime'].quantile(0.25)
Q3 = movie_details['normalized_runtime'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details['normalized_runtime'] < lower_bound) | (movie_details['normalized_runtime'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")

movie_details['normalized_vote_count'] = np.log1p(movie_details['vote_count']) # log normalizing

box = sns.boxplot(y=movie_details[movie_details['status'] == 'Released']['normalized_vote_count'])
box.set_title("Box Plot of vote_count")

Q1 = movie_details[movie_details['status'] == 'Released']['normalized_vote_count'].quantile(0.25)
Q3 = movie_details[movie_details['status'] == 'Released']['normalized_vote_count'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details[movie_details['status'] == 'Released']['normalized_vote_count'] < lower_bound) | (movie_details[movie_details['status'] == 'Released']['normalized_vote_count'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")

movie_details[(movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound)].sort_values(by='normalized_vote_count')

print(movie_details[(movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound)].sort_values(by='normalized_vote_count')['vote_count'].value_counts())
print(movie_details[(movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound)].sort_values(by='normalized_vote_count')['budget'].value_counts())
print(movie_details[(movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound)].sort_values(by='normalized_vote_count')[['budget', 'revenue']].value_counts())

movie_details[(movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound)].sort_values(by='normalized_vote_count')['revenue'].value_counts()

condition = (movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound) & (movie_details['budget'] == 0) & (movie_details['revenue'] == 0)
movie_details.drop(index=movie_details[condition].index, axis=0, inplace=True)

print(movie_details[(movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound)].sort_values(by='normalized_vote_count')['vote_count'].value_counts())
print(movie_details[(movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound)].sort_values(by='normalized_vote_count')['budget'].value_counts())
print(movie_details[(movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound)].sort_values(by='normalized_vote_count')[['budget', 'revenue']].value_counts())

movie_details[(movie_details['status'] == 'Released') & (movie_details['normalized_vote_count'] < lower_bound)].sort_values(by='normalized_vote_count')['revenue'].value_counts()

box = sns.boxplot(y=movie_details[movie_details['status'] == 'Released']['normalized_vote_count'])
box.set_title("Box Plot of vote_count")

movie_details['normalized_vote_average'] = np.log1p(movie_details['vote_average']) # log normalizing

box = sns.boxplot(y=movie_details[movie_details['status'] == 'Released']['normalized_vote_average'])
box.set_title("Box Plot of vote_average")

Q1 = movie_details[movie_details['status'] == 'Released']['normalized_vote_average'].quantile(0.25)
Q3 = movie_details[movie_details['status'] == 'Released']['normalized_vote_average'].quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_count = ((movie_details[movie_details['status'] == 'Released']['normalized_vote_average'] < lower_bound) | (movie_details[movie_details['status'] == 'Released']['normalized_vote_average'] > upper_bound)).sum()
print(f"Q1 {Q1}")
print(f"Q3 {Q3}")
print(f"IQR {IQR}")
print(f"lower_bound {lower_bound}")
print(f"upper_bound {upper_bound}")
print(f"Number of outliers: {outlier_count}")

print(movie_details[movie_details['status'] == 'Released']['vote_average'].max())
print(movie_details[movie_details['status'] == 'Released']['vote_average'].min())



"""#Dealing with movie_details and its dictionaries"""

movie_details['id'].duplicated().sum()

import ast
#fill missing values (nulls) with False
movie_details['belongs_to_collection'].fillna(False,inplace=True)


#If a cell’s value is a string , convert it into an actual dictionary.
# Otherwise (if it’s already a dict or False), leave it as is.
movie_details['belongs_to_collection'] = movie_details['belongs_to_collection'].apply(lambda x: ast.literal_eval(x) if isinstance(x, str) else x)

#For each value, if it is a dictionary (not false), extract its 'name' field; otherwise, leave it as False.
movie_details['belongs_to_collection'] = movie_details['belongs_to_collection'].apply(lambda x: x['name'] if x != False else False)

# We need to handle the genres to normalized form
movie_details['genres'] = movie_details['genres'].apply(lambda x: ast.literal_eval(x) if isinstance(x, str) else x)
movie_details['genres'] = movie_details['genres'].apply(lambda x: [i['name'] for i in x] if isinstance(x, list) else x)

movie_details['production_countries'] = movie_details['production_countries'].apply(lambda x: ast.literal_eval(x) if isinstance(x, str) else x)

movie_details['origin_country'] = movie_details['origin_country'].apply(lambda x: ast.literal_eval(x) if isinstance(x, str) else x)

movie_details['production_companies'] = movie_details['production_companies'].apply(lambda x: ast.literal_eval(x) if isinstance(x, str) else x)

movie_details['spoken_languages'] = movie_details['spoken_languages'].apply(lambda x: ast.literal_eval(x) if isinstance(x, str) else x)

genres = list()  #initialize an empty list to store movie genre pairs

for i in movie_details.index:  #loop through each movie in the dataset

    for j in movie_details['genres'][i]:  #loop through each genre for the movie

        genres.append([movie_details['id'][i], j]) # append the movie ID and genre to the list

genres = pd.DataFrame(genres, columns=['movie_id', 'genre'])

genres.to_csv('genres.csv', index=False)

country_data = []

for i in movie_details.index:
      for j in movie_details['origin_country'][i]:
          country_data.append([movie_details['id'][i], j])

country = pd.DataFrame(country_data, columns=["movie_id", 'country'])

country.to_csv('countries.csv', index=False)

companies = list()

for i in movie_details.index:
    for company in movie_details['production_companies'][i]:
        companies.append([movie_details['id'][i], company['name'], company['origin_country']])

companies = pd.DataFrame(companies, columns=['movie_id', 'company_name', 'country'])

companies.to_csv('companies.csv', index=False)

countries = list()

for i in movie_details.index:
    for country in movie_details['production_countries'][i]:
        countries.append([movie_details['id'][i], country['name']])

countries = pd.DataFrame(countries, columns=['movie_id', 'country'])

countries.to_csv('Prod_countries.csv', index=False)

langs = list()

for i in movie_details.index:
    for lang in movie_details['spoken_languages'][i]:
        langs.append([movie_details['id'][i], lang['english_name']])

langs = pd.DataFrame(langs, columns=['movie_id', 'lang'])

langs.to_csv('langs.csv', index=False)

columns = ["genres","origin_country", "spoken_languages", "production_countries", "production_companies"]
movie_details.drop(columns=columns, inplace=True)

movie_details

movie_details.to_csv('movie_details.csv', index=False)